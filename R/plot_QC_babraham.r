#' Generate Babraham Institute QC Plots for Single-Cell RNA-seq Data
#'
#' @description
#' Creates comprehensive quality control visualizations following the Babraham
#' Institute workflow, including novelty scores, largest gene analysis, and
#' dual scatter plots with QC metrics overlays. Supports both single Seurat
#' objects and lists of Seurat objects with optional parallel processing.
#'
#' @param seurat.obj A Seurat object or a list of Seurat objects. Each object
#'   should contain QC metrics computed by \code{\link{run_babraham_qc}}.
#' @param large.genes Numeric. Minimum number of cells in which a gene must be
#'   the largest expressed gene to be individually colored and labeled in plots.
#'   Genes appearing in fewer cells are grouped as "Other". Default: 100
#' @param filename Character string. Base name for the output TIFF file(s)
#'   (without extension). For lists of objects, object names will be appended.
#'   Default: "QC_Babraham"
#' @param ident Character string. Name of the metadata column to use for
#'   faceting in dual scatter plots. Default: "orig.ident"
#' @param feature.thres Numeric. Threshold for minimum number of genes
#'   (nFeature_RNA) per cell, shown as a dashed horizontal line in dual plots.
#'   Default: 500
#' @param count.thres Numeric. Threshold for minimum UMI counts (nCount_RNA)
#'   per cell, shown as a dashed vertical line in dual plots. Default: 1000
#' @param gene.thres Numeric. Threshold for maximum percentage of the largest
#'   gene per cell, shown as a dashed horizontal line in the largest gene plot.
#'   Default: 30
#' @param mt.thres Numeric. Threshold for maximum mitochondrial percentage,
#'   used for reference (not currently plotted as a line). Default: 10
#' @param rb.thres Numeric. Threshold for ribosomal percentage, used for
#'   reference (not currently plotted as a line). Default: 5
#' @param novelty.thres Numeric. Threshold for minimum novelty score
#'   (log10GenesPerUMI), shown as a dashed vertical line in the novelty
#'   histogram. Default: 0.7
#' @param novelty.diff.thres Numeric vector of length 2. Lower and upper
#'   thresholds for novelty difference (residuals from the novelty linear
#'   model), shown as dashed vertical lines. Default: c(-0.2, 0.2)
#' @param assay Character string. Name of the assay to use for plotting
#'   nCount and nFeature. Default: "RNA"
#' @param BPPARAM BiocParallelParam object for parallel processing when input
#'   is a list (e.g., MulticoreParam, SnowParam). If NULL, processes
#'   sequentially. Default: NULL
#'
#' @return
#' \itemize{
#'   \item For single Seurat object: Returns a patchwork plot object
#'   \item For list of Seurat objects: Returns a named list of patchwork plot
#'         objects, with names derived from the input list
#' }
#'
#' @details
#' The function generates a 3×2 grid layout (6 panels) for each sample:
#'
#' **Row 1 (3 panels):**
#' \itemize{
#'   \item **Novelty Histogram**: Distribution of log10GenesPerUMI across cells,
#'         colored by identity, with threshold line
#'   \item **Novelty Difference Histogram**: Distribution of novelty_diff
#'         (residuals from linear regression), with threshold lines
#'   \item **Largest Gene Scatter**: novelty_diff vs percent.Largest.Gene,
#'         colored by the identity of the largest gene (only genes appearing
#'         as largest in >large.genes cells are shown)
#' }
#'
#' **Row 2 (2 panels):**
#' \itemize{
#'   \item **Novelty QC Dual Plot**: nCount vs nFeature scatter plot with
#'         novelty_diff color gradient and the fitted linear regression line,
#'         faceted by ident
#'   \item **Largest Gene Dual Plot**: nCount vs nFeature scatter plot colored
#'         by largest gene identity, faceted by ident
#' }
#'
#' **Row 3 (2 panels):**
#' \itemize{
#'   \item **MT% Dual Plot**: nCount vs nFeature scatter plot with
#'         mitochondrial percentage color gradient, faceted by ident
#'   \item **RB% Dual Plot**: nCount vs nFeature scatter plot with ribosomal
#'         percentage color gradient, faceted by ident
#' }
#'
#' @section Required Metadata:
#' The Seurat object(s) must contain QC metrics generated by
#' \code{\link{run_babraham_qc}}:
#' \itemize{
#'   \item log10GenesPerUMI: Novelty score
#'   \item novelty_diff: Deviation from expected novelty
#'   \item largest_gene: Gene with highest expression per cell
#'   \item percent.Largest.Gene: Percentage of counts from largest gene
#'   \item percent.mt: Mitochondrial percentage
#'   \item percent.rb: Ribosomal percentage
#'   \item nCount_RNA, nFeature_RNA: Standard Seurat metrics
#' }
#'
#' Additionally, the linear model for novelty should be stored in
#' \code{seurat_obj@tools$novelty.lm}.
#'
#' @section Threshold Guidelines:
#' Default thresholds are starting points and should be adjusted based on your
#' data and biological system:
#' \itemize{
#'   \item **feature.thres** (500): Cells with fewer genes may be low quality
#'   \item **count.thres** (1000): Cells with fewer UMIs may be low quality
#'   \item **gene.thres** (30): Cells where one gene dominates may be stressed
#'         or damaged
#'   \item **novelty.thres** (0.7): Lower values indicate low complexity
#'   \item **novelty.diff.thres** (±0.2): Large deviations may indicate
#'         technical issues
#'   \item **mt.thres** (10): High mitochondrial content suggests cell stress
#'   \item **rb.thres** (5): High ribosomal content may indicate certain cell
#'         states
#' }
#'
#' @section Output Files:
#' For each Seurat object, saves a TIFF file with dimensions 18×15 inches at
#' 200 DPI resolution. File naming:
#' \itemize{
#'   \item Single object: "{filename}.tiff"
#'   \item List objects: "{filename}{name}_QC_Babraham.tiff"
#'   \item Combined plot (≤4 objects): "{filename}_combined.tiff"
#' }
#'
#' @section Color Schemes:
#' \itemize{
#'   \item **Largest genes**: Uses RColorBrewer Set1 palette with grey for the
#'         most common gene, "Other" in light grey
#'   \item **Novelty difference**: Blue (negative) to grey (zero) to red (positive)
#'   \item **MT% and RB%**: Black to blue to green to red to yellow gradient
#' }
#'
#' @section Parallel Processing:
#' When processing multiple samples, parallel processing can speed up computation:
#' \preformatted{
#' library(BiocParallel)
#' # For Unix-like systems (Linux, macOS)
#' param <- MulticoreParam(workers = 4)
#'
#' # For Windows
#' param <- SnowParam(workers = 4, type = "SOCK")
#' }
#'
#' @examples
#' \dontrun{
#' # First, compute QC metrics
#' seurat_obj <- run_babraham_qc(seurat_obj)
#'
#' # Basic plotting with default parameters
#' plot_QC_babraham(seurat_obj)
#'
#' # Custom thresholds for stricter filtering
#' plot_QC_babraham(
#'   seurat.obj = seurat_obj,
#'   filename = "Strict_QC",
#'   feature.thres = 1000,
#'   count.thres = 2000,
#'   gene.thres = 20,
#'   mt.thres = 5,
#'   novelty.thres = 0.8,
#'   novelty.diff.thres = c(-0.1, 0.1)
#' )
#'
#' # Plot only highly abundant largest genes
#' plot_QC_babraham(
#'   seurat.obj = seurat_obj,
#'   large.genes = 500,  # Only show genes that are largest in >500 cells
#'   filename = "Common_genes_QC"
#' )
#'
#' # Process multiple samples with parallel processing
#' library(BiocParallel)
#' seurat_list <- list(
#'   Sample1 = seurat_obj1,
#'   Sample2 = seurat_obj2,
#'   Sample3 = seurat_obj3
#' )
#'
#' # Each object should have QC metrics
#' seurat_list <- lapply(seurat_list, run_babraham_qc)
#'
#' # Generate plots in parallel
#' param <- MulticoreParam(workers = 3)
#' plots <- plot_QC_babraham(
#'   seurat.obj = seurat_list,
#'   filename = "MultiSample_",
#'   BPPARAM = param
#' )
#'
#' # Use different identity for faceting
#' plot_QC_babraham(
#'   seurat.obj = seurat_obj,
#'   ident = "seurat_clusters",  # Facet by cluster instead of orig.ident
#'   filename = "Cluster_QC"
#' )
#' }
#'
#' @references
#' Babraham Institute scRNA-seq Course:
#' https://www.bioinformatics.babraham.ac.uk/training/10XRNASeq/seurat_workflow.html
#'
#' @importFrom ggplot2 ggplot aes geom_histogram geom_point geom_blank
#'   geom_hline geom_vline geom_abline scale_colour_manual scale_color_gradientn
#'   scale_colour_gradient2 scale_x_log10 scale_y_log10 scale_x_continuous
#'   facet_wrap labs ggtitle xlab ylab theme_classic theme_void
#' @importFrom dplyr filter mutate arrange pull
#' @importFrom RColorBrewer brewer.pal
#' @importFrom patchwork wrap_plots
#' @importFrom scales trans_format math_format
#' @importFrom BiocParallel bplapply
#' @importFrom grDevices colorRampPalette
#'
#' @seealso
#' \code{\link{run_babraham_qc}} for computing the required QC metrics
#' \code{\link{plot_QC_classic}} for classic QC visualizations
#' \code{\link{plot_QC_UMAP}} for UMAP-based QC visualizations
#' \code{\link[BiocParallel]{BiocParallelParam}} for parallel processing options
#'
#' @export
plot_QC_babraham <- function(seurat.obj, large.genes = 100, filename = "QC_Babraham", ident = "orig.ident",
                             feature.thres = 500, count.thres = 1000,
                             gene.thres = 30, mt.thres = 10, rb.thres = 5,
                             novelty.thres = 0.7, novelty.diff.thres = c(-0.2, 0.2),
                             assay = "RNA", BPPARAM = NULL){

  # Load required libraries
  library(ggplot2)
  library(dplyr)
  library(RColorBrewer)
  library(patchwork)
  library(scales)

  # Check if BPPARAM is provided and load BiocParallel if needed
  if (!is.null(BPPARAM)) {
    if (!requireNamespace("BiocParallel", quietly = TRUE)) {
      stop("BiocParallel package is required for parallel processing. Please install it.")
    }
    library(BiocParallel)
  }

  # Helper function to process a single Seurat object
  process_single_seurat <- function(seurat_obj, obj_name = NULL) {

    # If obj_name is not provided, try to get it from the object or use a default
    if (is.null(obj_name)) {
      obj_name <- deparse(substitute(seurat_obj))
      if (obj_name == "X[[i]]" || grepl("\\[\\[", obj_name)) {
        obj_name <- paste0("Object_", sample(1000:9999, 1))
      }
    }

    # histogram novelty
    novelty.histogram <- seurat_obj@meta.data %>%
      ggplot(aes(x=log10GenesPerUMI, color = Idents(seurat_obj), fill=Idents(seurat_obj))) +
      geom_histogram(alpha = 0.2, position="identity", bins=50) +
      theme_classic() +
      ylab("Cell numbers") +
      xlab("log10 Genes per UMI") +
      geom_vline(xintercept = novelty.thres, linetype = "dashed", alpha = 0.7) +
      labs(color = "Identity", fill = "Identity") +
      ggtitle(paste0("Novelty - ", obj_name))

    # Novelty deviation plot
    novelty.diff.plot <- seurat_obj@meta.data %>%
      ggplot(aes(color=Idents(seurat_obj), x=novelty_diff, fill= Idents(seurat_obj))) +
      geom_histogram(alpha = 0.2, position="identity", bins=50) +
      scale_x_continuous() +
      theme_classic() +
      ylab("Cell numbers") +
      xlab("Novelty Difference") +
      geom_vline(xintercept = novelty.diff.thres, linetype = "dashed", alpha = 0.7) +
      labs(color = "Identity", fill = "Identity") +
      ggtitle(paste0("Novelty Diff - ", obj_name))

    # Weight of most abundant gene
    gene_counts <- table(seurat_obj@meta.data[["largest_gene"]])
    largest_gene_list <- data.frame(
      largest_gene = names(gene_counts),
      n = as.numeric(gene_counts)
    ) %>%
      arrange(desc(n))

    largest_genes_to_plot <- largest_gene_list %>%
      filter(n > large.genes) %>%
      pull(largest_gene)

    # Create color mapping for largest genes (to be reused)
    n_colors <- length(largest_genes_to_plot)
    if (n_colors == 0) {
      gene_colors <- NULL
    } else if (n_colors == 1) {
      gene_colors <- c("grey")
      names(gene_colors) <- largest_genes_to_plot[1]
    } else {
      gene_colors <- c("grey", colorRampPalette(brewer.pal(min(9, n_colors-1), "Set1"))(n_colors - 1))
      names(gene_colors) <- largest_genes_to_plot
    }

    # Change your scale according to number of "widely expressed genes"
    plot.large.gene <- seurat_obj@meta.data %>%
      filter(largest_gene %in% largest_genes_to_plot) %>%
      mutate(largest_gene = factor(largest_gene, levels = largest_genes_to_plot)) %>%
      arrange(largest_gene) %>%
      {
        if (nrow(.) == 0) {
          # Handle case where no genes meet threshold
          return(ggplot() +
                   geom_blank() +
                   theme_void() +
                   labs(title = paste("No genes with >", large.genes, "cells -", obj_name)))
        }

        ggplot(., aes(x = novelty_diff, y = percent.Largest.Gene, colour = largest_gene)) +
          geom_point() +
          scale_colour_manual(values = gene_colors) +
          theme_classic() +
          xlab("Novelty Difference") +
          ylab("Percent Largest Gene") +
          labs(color = "Largest Gene") +
          geom_hline(yintercept = gene.thres, linetype = "dashed", alpha = 0.7) +
          geom_vline(xintercept = novelty.diff.thres, linetype = "dashed", alpha = 0.7) +
          ggtitle(paste0("Largest Genes - ", obj_name))
      }

    # NEW PLOT: dual plot with largest gene coloring
    plot_dual_largest_gene <- if (is.null(gene_colors) || length(gene_colors) == 0) {
      # Handle case where no genes meet threshold
      ggplot() +
        geom_blank() +
        theme_void() +
        labs(title = paste("No genes with >", large.genes, "cells -", obj_name))
    } else {
      # Create a version of metadata with largest gene info for plotting
      plot_data <- seurat_obj@meta.data %>%
        mutate(
          largest_gene_plot = ifelse(largest_gene %in% largest_genes_to_plot,
                                     as.character(largest_gene),
                                     "Other"),
          largest_gene_plot = factor(largest_gene_plot,
                                     levels = c(names(gene_colors), "Other"))
        )

      # Add "Other" color if needed
      plot_colors <- gene_colors
      if (any(plot_data$largest_gene_plot == "Other")) {
        plot_colors <- c(gene_colors, "Other" = "lightgrey")
      }

      ggplot(plot_data, aes(x = .data[[paste0("nCount_", assay)]], y = .data[[paste0("nFeature_", assay)]], colour = largest_gene_plot)) +
        geom_point(size = 0.7) +
        scale_colour_manual(values = plot_colors, drop = FALSE) +
        theme_classic() +
        geom_hline(yintercept = feature.thres, linetype = "dashed", alpha = 0.7) +
        geom_vline(xintercept = count.thres, linetype = "dashed", alpha = 0.7) +
        scale_x_log10(labels = trans_format("log10", math_format(10^.x))) +
        scale_y_log10() +
        labs(color = "Largest Gene") +
        xlab(paste0("nCount_", assay)) +
        ylab(paste0("nFeature_", assay)) +
        facet_wrap(as.formula(paste0("~", ident))) +
        ggtitle(paste0("Largest Gene QC - ", obj_name))
    }

    # dual plot with novelty_diff scale
    novelty_scale <- min(c(max(seurat_obj@meta.data$novelty_diff),
                           abs(min(seurat_obj@meta.data$novelty_diff))))

    plot_dualQC <- seurat_obj@meta.data %>%
      mutate(novelty_diff = replace(novelty_diff, novelty_diff < -0.1, -0.1)) %>%
      ggplot(aes(x = .data[[paste0("nCount_", assay)]], y = .data[[paste0("nFeature_", assay)]], colour = novelty_diff)) +
      geom_point(size=0.5) +
      geom_abline(slope=seurat_obj@tools$novelty.lm$coefficients[2],
                  intercept = seurat_obj@tools$novelty.lm$coefficients[1]) +
      scale_colour_gradient2(low="blue2", mid="grey", high="red2") +
      theme_classic() +
      geom_hline(yintercept = feature.thres, linetype = "dashed", alpha = 0.7) +
      geom_vline(xintercept = count.thres, linetype = "dashed", alpha = 0.7) +
      scale_x_log10(labels = trans_format("log10", math_format(10^.x))) +
      scale_y_log10() +
      labs(color = "Novelty Diff") +
      xlab(paste0("nCount_", assay)) +
      ylab(paste0("nFeature_", assay)) +
      facet_wrap(as.formula(paste0("~", ident))) +
      ggtitle(paste0("Novelty QC - ", obj_name))

    # dual plot with percent.mt
    plot_dual_mt <- seurat_obj@meta.data %>%
      ggplot(aes(x = .data[[paste0("nCount_", assay)]], y = .data[[paste0("nFeature_", assay)]], colour = percent.mt)) +
      geom_point(size = 0.7) +
      scale_color_gradientn(colors = c("black", "blue", "green2", "red", "yellow")) +
      ggtitle(paste0("MT% - ", obj_name)) +
      geom_hline(yintercept = feature.thres, linetype = "dashed", alpha = 0.7) +
      geom_vline(xintercept = count.thres, linetype = "dashed", alpha = 0.7) +
      scale_x_log10(labels = trans_format("log10", math_format(10^.x))) +
      scale_y_log10() +
      theme_classic() +
      xlab(paste0("nCount_", assay)) +
      ylab(paste0("nFeature_", assay)) +
      labs(color = "% MT") +
      facet_wrap(as.formula(paste0("~", ident)))

    # dual plot with percent.rb
    plot_dual_rb <- seurat_obj@meta.data %>%
      ggplot(aes(x = .data[[paste0("nCount_", assay)]], y = .data[[paste0("nFeature_", assay)]], colour = percent.rb)) +
      geom_point(size = 0.7) +
      scale_color_gradientn(colors = c("black", "blue", "green2", "red", "yellow")) +
      ggtitle(paste0("RB% - ", obj_name)) +
      geom_hline(yintercept = feature.thres, linetype = "dashed", alpha = 0.7) +
      geom_vline(xintercept = count.thres, linetype = "dashed", alpha = 0.7) +
      scale_x_log10(labels = trans_format("log10", math_format(10^.x))) +
      scale_y_log10() +
      theme_classic() +
      xlab(paste0("nCount_", assay)) +
      ylab(paste0("nFeature_", assay)) +
      labs(color = "% RB") +
      facet_wrap(as.formula(paste0("~", ident)))

    # Combine plots for this object - 3x2x2 GRID LAYOUT
    final_plot <- (novelty.histogram + novelty.diff.plot + plot.large.gene) /
      (plot_dualQC + plot_dual_largest_gene) /
      (plot_dual_mt + plot_dual_rb)

    return(list(plot = final_plot, name = obj_name))
  }

  # Main function logic
  if (is.list(seurat.obj)) {
    # Handle list of Seurat objects

    # Get names for the objects
    obj_names <- names(seurat.obj)
    if (is.null(obj_names)) {
      obj_names <- paste0("Object_", seq_along(seurat.obj))
    }

    # Create a function for parallel processing
    process_wrapper <- function(i) {
      process_single_seurat(seurat.obj[[i]], obj_names[i])
    }

    # Process objects (either in parallel or sequentially)
    if (!is.null(BPPARAM)) {
      # Parallel processing
      cat("Processing", length(seurat.obj), "Seurat objects in parallel...\n")
      results <- BiocParallel::bplapply(seq_along(seurat.obj), process_wrapper, BPPARAM = BPPARAM)
    } else {
      # Sequential processing
      cat("Processing", length(seurat.obj), "Seurat objects sequentially...\n")
      results <- lapply(seq_along(seurat.obj), process_wrapper)
    }

    # Extract plots and names
    plots <- lapply(results, function(x) x$plot)
    names(plots) <- sapply(results, function(x) x$name)

    # Save individual plots (adjusted dimensions for 3x2x2 grid)
    for (i in seq_along(plots)) {
      plot_filename <- paste0(filename, names(plots)[i],"_QC_Babraham")
      SaveFigure(plots[[i]], name = plot_filename, type = "tiff", width = 18, height = 15, res = 200)
    }

    # Create a combined plot if there are multiple objects (optional)
    if (length(plots) <= 4) {
      # If 4 or fewer objects, create a combined plot
      combined_plot <- wrap_plots(plots, ncol = 2)
      combined_filename <- paste0(filename, "_combined")
      SaveFigure(combined_plot, name = combined_filename, type = "tiff",
                 width = 36, height = 30 * ceiling(length(plots)/2), res = 200)
    }

    cat("Processed", length(seurat.obj), "objects. Individual plots saved.\n")
    return(plots)

  } else {
    # Handle single Seurat object (original functionality)
    result <- process_single_seurat(seurat.obj, filename)

    # Save the plot (adjusted dimensions for 3x2x2 grid)
    SaveFigure(result$plot, name = filename, type = "tiff", width = 18, height = 15, res = 200)

    return(result$plot)
  }
}
